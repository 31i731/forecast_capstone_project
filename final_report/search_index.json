[["index.html", "Data Science Capstone Project Solar Panel Forecast 1 Description of the business questions 1.1 Problem formulation 1.2 Project plan", " Data Science Capstone Project Solar Panel Forecast Group 4 - Vassili Privalihhin, Marijana Zanetic, Anna Erdi 1 Description of the business questions The climate of our planet is undergoing significant change, especially in recent years. This process is only accelerating and we do not see the end yet, especially not the solution to it. That is why every single solar cell we install and every kW we produce from a renewable energy source is so important. The widest possible use of solar energy protects our Earths climate and reduces the pollution caused by our civilization, as no carbon dioxide is produced during its use. Its advantage in this respect is also indisputable compared to fossil fuel power plants. An extremely big advantage of solar energy in this regard is that every single person can do something to reduce pollution on our planet thanks to solar energy. You can install a solar panel and solar collector in your home, with which you can even satisfy the electricity needs of your electric car. But companies and states can also do this by setting up solar power plants on a large scale in order to make the most of the benefits of solar energy. 1.1 Problem formulation When the sun is not shining, the solar panels cannot produce energy, therefore electricity supply has to be taken from other resources. This can be a problem if the other resources are still created using fossil fuels. In order to minimize our fossil fuel usage and maximize the sustainable production, it is important to get an estimation about the energy that is going to be produced at certain times, so either our consumption can be adjusted to it, or if our consumption is still higher, we can plan the procurement from other renewable sources to make up the missing amounts of electricity. 1.2 Project plan Our business goal is to predict the amount of electricity that is going to be produced weekly, so that the production of our solar panels can be incorporated with other energy production methods. Business questions: What models can be used for forecasting? How to assess the performance of the models? Which model performs the best? "],["description-of-the-data-eda.html", " 2 Description of the data - EDA 2.1 Setup 2.2 Sun radiation 2.3 Energy production 2.4 Summary of all the datasets 2.5 Weather data description", " 2 Description of the data - EDA We have data from three buildings located in Vienna, each with solar panels equipped. There are 2 different data collected from their sensors. One is the energy produced in kW, the other is the sun radiation. The data is collected between 2016 August 09 and 2019 July 01 with 15 minute intervals. Furthermore, we have acquired our weather data from https://www.worldweatheronline.com/developer/api/docs/historical-weather-api.aspx using the Python script called importWeatherData.py attached in the folder. The past weather API allows us to retrieve weather data from specified time period and location. It also supports retrieval of data for multiple locations at once. In our case, we only needed data from Vienna because all the three buildings are in Vienna. Also, we have retrieved data for every 24 hours(every day) because it was the most convenient time range we could use. 2.1 Setup # loading the libraries suppressPackageStartupMessages({ library(ggplot2) library(data.table) library(forecast) library(tidyr) library(lubridate) library(dplyr) library(tseries) library(plotly) library(nortest) library(astsa) }) Loading the data # &#39;sun&#39; - sensor data, otherwise the energy produced building_2_sun &lt;- readRDS(&quot;data/Building 2 sun.rds&quot;) building_2 &lt;- readRDS(&quot;data/Building 2.rds&quot;) building_5_sun &lt;- readRDS(&quot;data/Building 5 sun.rds&quot;) building_5 &lt;- readRDS(&quot;data/Building 5.rds&quot;) building_8_sun &lt;- readRDS(&quot;data/Building 8 sun.rds&quot;) building_8 &lt;- readRDS(&quot;data/Building 8.rds&quot;) setDT(building_2_sun) setDT(building_2) setDT(building_5_sun) setDT(building_5) setDT(building_8_sun) setDT(building_8) setnames(building_2_sun, &quot;1302611&quot;, &quot;sun&quot;) setnames(building_2, &quot;1490017&quot;, &quot;energy_produced&quot;) setnames(building_5_sun, &quot;1328370&quot;, &quot;sun&quot;) setnames(building_5, &quot;1328347&quot;, &quot;energy_produced&quot;) setnames(building_8_sun, &quot;1302169&quot;, &quot;sun&quot;) setnames(building_8, &quot;1498763&quot;, &quot;energy_produced&quot;) # weather data weather &lt;- fread(&quot;data/vienna.csv&quot;, na.strings = c(&quot;No moonrise&quot;, &quot;No moonset&quot;)) 2.2 Sun radiation columns &lt;- c(&quot;building_2_sun&quot;, &quot;building_5_sun&quot;, &quot;building_8_sun&quot;) plots &lt;- lapply(columns, function(col) { plot_ly(data = get(col)[, .(sun=mean(sun)), by=.(timestamp=floor_date(timestamp, &quot;weeks&quot;))], x = ~timestamp, y = ~sun, type = &quot;scatter&quot;, mode = &quot;lines&quot;) %&gt;% layout(yaxis = list(title = paste(&quot;Sun radiation on&quot;, gsub(&quot;_sun&quot;, &quot;&quot;, col), sep=&quot;\\n&quot;)), xaxis = list(showticklabels=T), showlegend=F, title=&quot;Weekly average sun radiation measured on each building&quot;)}) subplot(plots, titleY = T, nrows = 3) The sun radiation measured on each building is quite similar, indicating that the buildings are in close proximity to each other. We can also say that the most of sun radiation takes place in the middle of summer, while the least in the winter, what makes complete sense. 2.3 Energy production columns &lt;- c(&quot;building_2&quot;, &quot;building_5&quot;, &quot;building_8&quot;) plots &lt;- lapply(columns, function(col) { plot_ly(data = get(col)[, .(energy_produced=sum(energy_produced)), by=.(timestamp=floor_date(timestamp, &quot;weeks&quot;))], x = ~timestamp, y = ~energy_produced, type = &quot;scatter&quot;, mode = &quot;lines&quot;) %&gt;% layout(yaxis = list(title = paste(&quot;Energy from&quot;, gsub(&quot;_&quot;, &quot; &quot;, as.character(col)), sep=&quot;\\n&quot;)), xaxis = list(showticklabels=T), showlegend=F, title=&quot;Weekly aggregated energy production of each building&quot;)}) subplot(plots, titleY = T, nrows = 3) As we can see, the data from building 2 deviates from building 5 and 8, because it has some really extreme values. So well take a closer look at the outliers there. As with sun radiation, the most amount of energy produced is in the summer seasons and the least in winter seasons, which also indicates some decent correlation between these two features. 2.4 Summary of all the datasets Building 2 summary(building_2_sun[,sun]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -0.0867 0.0000 0.1733 130.8078 176.2042 1089.6600 summary(building_2[,energy_produced]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -32716.85 0.00 0.00 0.49 0.55 32716.85 Building 5 summary(building_5_sun[,sun]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -1.056 1.869 12.919 146.211 180.131 1286.025 summary(building_5[,energy_produced]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 0.000 0.000 1.591 2.032 18.560 Building 8 summary(building_8_sun[,sun]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 3.354 3.519 3.675 132.371 177.771 1068.678 summary(building_8[,energy_produced]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0000 0.0000 0.0000 0.3009 0.3760 2.3920 As you can see, the range of values of energy_produced feature in the building_2 is significantly different from all the other two corresponding features of other datasets, even though the median and the mean are quite similar to others. Let us count NAs if there are any: sum(is.na(building_2_sun)) ## [1] 0 sum(is.na(building_2)) ## [1] 0 sum(is.na(building_5_sun)) ## [1] 0 sum(is.na(building_5)) ## [1] 0 sum(is.na(building_8_sun)) ## [1] 0 sum(is.na(building_8)) ## [1] 0 No NAs found in any of the datasets! Now let us see some boxplots, which potentially show some outliers par(mfrow=c(2,3)) boxplot(building_2[,energy_produced], main=&quot; Building 2 energy&quot;) boxplot(building_5[,energy_produced], main=&quot; Building 5 energy&quot;) boxplot(building_8[,energy_produced], main=&quot; Building 8 energy&quot;) boxplot(building_2_sun[,sun], main=&quot;Building 2 sun&quot;) boxplot(building_5_sun[,sun], main=&quot;Building 5 sun&quot;) boxplot(building_8_sun[,sun], main=&quot;Building 8 sun&quot;) All buildings have some number of outliers, especially above the maximum. Now let us see the distributions of the data a &lt;- density(building_2[,energy_produced]) b &lt;- density(building_2_sun[,sun]) c &lt;- density(building_5[,energy_produced]) d &lt;- density(building_5_sun[,sun]) e &lt;- density(building_8[,energy_produced]) f &lt;- density(building_8_sun[,sun]) fig1 = plot_ly(x=a$x, y=a$y, type= &quot;scatter&quot;, mode = &quot;lines&quot;, fill = &quot;tozeroy&quot;, name=&quot;Energy produced of building 2&quot;) fig2 = plot_ly(x=b$x, y=b$y, type= &quot;scatter&quot;, mode = &quot;lines&quot;, fill = &quot;tozeroy&quot;, name=&quot;Sun ratiation of building 2&quot;) fig3 = plot_ly(x=c$x, y=c$y, type= &quot;scatter&quot;, mode = &quot;lines&quot;, fill = &quot;tozeroy&quot;, name=&quot;Energy produced of building 5&quot;) fig4 = plot_ly(x=d$x, y=d$y, type= &quot;scatter&quot;, mode = &quot;lines&quot;, fill = &quot;tozeroy&quot;, name=&quot;Sun ratiation of building 5&quot;) fig5 = plot_ly(x=e$x, y=e$y, type= &quot;scatter&quot;, mode = &quot;lines&quot;, fill = &quot;tozeroy&quot;, name=&quot;Energy produced of building 8&quot;) fig6 = plot_ly(x=f$x, y=f$y, type= &quot;scatter&quot;, mode = &quot;lines&quot;, fill = &quot;tozeroy&quot;, name=&quot;Sun ratiation of building 8&quot;) fig &lt;- subplot(fig1, fig2, fig3, fig4, fig5, fig6, nrows = 6) fig Distributions seem to be normal, however we can see that there is a number of extreme values, basically what we saw in the boxplots as well. Also, energy produced of building 2 is of different range compared to others, which is weird. Plotting sun radiation vs energy produced on one plot building_5_sun %&gt;% plot_ly( x=~timestamp, y=~sun, type=&quot;scatter&quot;, mode=&quot;lines&quot;, name=&quot;sun radiation&quot;, line = list(color=&#39;#ff7f0e&#39;) ) %&gt;% add_trace( inherit = F, data=building_5, x=~timestamp, y=~energy_produced, type=&quot;scatter&quot;, mode=&quot;lines&quot;, name=&quot;energy produced&quot;, yaxis = &quot;y2&quot;, line = list(color = &#39;#1f77b4&#39;) ) %&gt;% layout( title = &quot;Building 5&quot;, yaxis2 = list( tickfont = list(color = &#39;#ff7f0e&#39;), overlaying = &quot;y&quot;, side = &quot;right&quot;, title = &quot;second y axis - energy&quot; ) ) By rescaling the two data sets, we plotted them together. And it clearly shows that when the sun radiation is higher, there is a proportional growth in the produced energy, so there is correlation! But are there maybe other factors that could influence the energy production? 2.5 Weather data description Lets examine how it looks like: summary(weather) ## date_time maxtempC mintempC totalSnow_cm sunHour uvIndex moon_illumination moonrise moonset ## Min. :2016-08-09 Min. :-8.0 Min. :-13.000 Min. : 0.0000 Min. : 3.20 Min. :1.000 Min. : 0.00 Length:1057 Length:1057 ## 1st Qu.:2017-04-30 1st Qu.: 7.0 1st Qu.: 2.000 1st Qu.: 0.0000 1st Qu.: 7.70 1st Qu.:2.000 1st Qu.: 19.00 Class :character Class :character ## Median :2018-01-19 Median :15.0 Median : 7.000 Median : 0.0000 Median :10.30 Median :3.000 Median : 46.00 Mode :character Mode :character ## Mean :2018-01-19 Mean :15.1 Mean : 7.102 Mean : 0.1435 Mean :10.09 Mean :3.426 Mean : 46.25 ## 3rd Qu.:2018-10-10 3rd Qu.:23.0 3rd Qu.: 13.000 3rd Qu.: 0.0000 3rd Qu.:13.50 3rd Qu.:5.000 3rd Qu.: 73.00 ## Max. :2019-07-01 Max. :37.0 Max. : 22.000 Max. :18.3000 Max. :14.50 Max. :8.000 Max. :100.00 ## sunrise sunset DewPointC FeelsLikeC HeatIndexC WindChillC WindGustKmph cloudcover humidity ## Length:1057 Length:1057 Min. :-15.000 Min. :-18.000 Min. :-10.00 Min. :-18.000 Min. : 4.00 Min. : 0.00 Min. :37.00 ## Class :character Class :character 1st Qu.: 0.000 1st Qu.: 1.000 1st Qu.: 4.00 1st Qu.: 1.000 1st Qu.:13.00 1st Qu.: 16.00 1st Qu.:65.00 ## Mode :character Mode :character Median : 6.000 Median : 9.000 Median : 11.00 Median : 9.000 Median :19.00 Median : 34.00 Median :72.00 ## Mean : 5.585 Mean : 9.209 Mean : 11.04 Mean : 9.066 Mean :20.04 Mean : 39.53 Mean :72.16 ## 3rd Qu.: 12.000 3rd Qu.: 18.000 3rd Qu.: 18.00 3rd Qu.: 18.000 3rd Qu.:26.00 3rd Qu.: 61.00 3rd Qu.:80.00 ## Max. : 20.000 Max. : 30.000 Max. : 30.00 Max. : 29.000 Max. :54.00 Max. :100.00 Max. :99.00 ## precipMM pressure tempC visibility winddirDegree windspeedKmph location ## Min. : 0.000 Min. : 994 Min. :-8.0 Min. : 0.000 Min. : 23.0 Min. : 3.00 Length:1057 ## 1st Qu.: 0.000 1st Qu.:1013 1st Qu.: 7.0 1st Qu.: 9.000 1st Qu.:154.0 1st Qu.: 8.00 Class :character ## Median : 0.300 Median :1018 Median :15.0 Median :10.000 Median :227.0 Median :12.00 Mode :character ## Mean : 2.542 Mean :1018 Mean :15.1 Mean : 9.202 Mean :224.9 Mean :13.06 ## 3rd Qu.: 2.800 3rd Qu.:1023 3rd Qu.:23.0 3rd Qu.:10.000 3rd Qu.:291.0 3rd Qu.:17.00 ## Max. :45.400 Max. :1043 Max. :37.0 Max. :10.000 Max. :350.0 Max. :38.00 str(weather) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 1057 obs. of 25 variables: ## $ date_time : IDate, format: &quot;2016-08-09&quot; &quot;2016-08-10&quot; &quot;2016-08-11&quot; &quot;2016-08-12&quot; ... ## $ maxtempC : int 26 14 19 19 25 29 26 25 23 26 ... ## $ mintempC : int 15 12 9 9 14 15 15 14 15 13 ... ## $ totalSnow_cm : num 0 0 0 0 0 0 0 0 0 0 ... ## $ sunHour : num 12.4 10.3 14.5 12.4 12.4 14.5 14.5 13.4 14.5 14.5 ... ## $ uvIndex : int 5 3 5 4 5 6 5 5 5 6 ... ## $ moon_illumination: int 39 46 53 61 68 75 82 90 97 100 ... ## $ moonrise : chr &quot;12:29 PM&quot; &quot;01:29 PM&quot; &quot;02:27 PM&quot; &quot;03:26 PM&quot; ... ## $ moonset : chr &quot;11:21 PM&quot; &quot;11:51 PM&quot; NA &quot;12:23 AM&quot; ... ## $ sunrise : chr &quot;05:41 AM&quot; &quot;05:43 AM&quot; &quot;05:44 AM&quot; &quot;05:45 AM&quot; ... ## $ sunset : chr &quot;08:18 PM&quot; &quot;08:16 PM&quot; &quot;08:15 PM&quot; &quot;08:13 PM&quot; ... ## $ DewPointC : int 14 12 7 9 14 15 14 12 11 11 ... ## $ FeelsLikeC : int 21 12 12 14 18 23 21 19 18 19 ... ## $ HeatIndexC : int 21 13 14 15 19 23 21 19 18 19 ... ## $ WindChillC : int 20 12 12 14 18 22 20 19 18 19 ... ## $ WindGustKmph : int 17 21 26 19 13 9 15 6 14 14 ... ## $ cloudcover : int 46 76 20 49 62 13 24 56 36 22 ... ## $ humidity : int 68 90 66 68 75 66 68 67 67 63 ... ## $ precipMM : num 6.1 28.2 0.1 0.1 2 2.3 1.8 1.7 1.5 0.1 ... ## $ pressure : int 1017 1018 1022 1025 1025 1022 1021 1017 1013 1012 ... ## $ tempC : int 26 14 19 19 25 29 26 25 23 26 ... ## $ visibility : int 10 8 10 10 8 10 10 10 10 10 ... ## $ winddirDegree : int 283 328 314 275 237 244 149 64 287 173 ... ## $ windspeedKmph : int 12 14 17 13 7 6 9 4 10 8 ... ## $ location : chr &quot;vienna&quot; &quot;vienna&quot; &quot;vienna&quot; &quot;vienna&quot; ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; We can see that this dataset includes many features like maximum and minimum temperature, wind data and moon data, precipitation, etc., which form a complete overview of weather in Vienna. Not all of these features are relevant for our purpose, but we will deal with this in the prepocessing part. Check if there are missing values: colSums(is.na(weather)) ## date_time maxtempC mintempC totalSnow_cm sunHour uvIndex moon_illumination moonrise moonset ## 0 0 0 0 0 0 0 36 36 ## sunrise sunset DewPointC FeelsLikeC HeatIndexC WindChillC WindGustKmph cloudcover humidity ## 0 0 0 0 0 0 0 0 0 ## precipMM pressure tempC visibility winddirDegree windspeedKmph location ## 0 0 0 0 0 0 0 We have some missing values in our weather dataset. However, these values are not really relevant as they are only in columns moonrise and moonset. We will later deal with this. We had the assumption that in the weather dataset there might be some other factors that could influence the energy production. Such factors could be clouds, number of sunny hours and UV radiation. Lets try to plot how the clouds influence the produced energy: weather[, .(avg=mean(cloudcover)), by=.(date=floor_date(date_time, &quot;weeks&quot;))] %&gt;% plot_ly( x=~date, y=~avg, name=&quot;Weekly average\\ncloudcover&quot;, type=&quot;scatter&quot;, mode=&quot;lines&quot; ) %&gt;% add_trace( inherit = F, data=building_5_sun[, .(daily_avg=mean(sun)), by=.(day=floor_date(timestamp, &quot;weeks&quot;))], x=~day, y=~daily_avg, type=&quot;scatter&quot;, mode=&quot;lines&quot;, name=&quot;Weekly average\\nsun radiation&quot; ) %&gt;% layout(title=&quot;Cloudcover vs Sun Radiation&quot;, yaxis = list(title = &quot; &quot;), xaxis = list(title = &quot; &quot;)) On the plot above, we can see the weekly aggregated cloudcover and run radiation from two different datasets. One is provided by our sensor, the other is from a public API. But we can clearly see that our weather data is accurate, because even though they are on a different scale, we can see that when there is a higher cloudcover, there is less sunshine, or to be more precise, they are the inverse of each other. "],["description-of-the-adopted-methodology.html", " 3 Description of the adopted methodology 3.1 Preprocessing 3.2 Feature engineering 3.3 Modeling", " 3 Description of the adopted methodology The adopted methodolgy consists of data preparation, feature engineering and modelling. In the following section these parts are described in more details. 3.1 Preprocessing In the preprocessing part we are going to deal with the outliers and NA values of each building and the weather data. 3.1.1 Outliers, NAs 3.1.1.1 Building 2 Weve seen in the previous chapter, that building 2 has some extreme outliers. Lets plot both the energy produced and the sun radiation together: building_2 %&gt;% plot_ly( x=~timestamp, y=~energy_produced, type=&quot;scatter&quot;, mode=&quot;lines&quot;, name=&quot;enery produced&quot; ) %&gt;% add_trace( inherit = F, data=building_2_sun, x=~timestamp, y=~sun, type=&quot;scatter&quot;, mode=&quot;lines&quot;, opacity=0.5, name=&quot;sun&quot; ) We can see that there is nothing extreme anomaly in the sunshine, therefore those outliers cannot be explained and most likely are wrong values. As on the other building the range of produced energy is between 0 and 100, we have decided to cut off the outliers here based on this criteria. building_2 &lt;- building_2[energy_produced &lt; 100 &amp; energy_produced &gt;= 0] 3.1.1.2 Weather In order to be able to merge the data later on, we have to change the type of date_time column to POSIXct: weather[,date_time := as.POSIXct(date_time, format = &quot;%d/%m/%Y&quot;)] # 31/08/2016 We notice that there is a column called location. This is due to the Weather API support for downloading data from multiple locations in the same dataset. As the location is always the same (Vienna), we decide to drop it. weather[,location := NULL] 3.1.2 Merging the data We have to merge each of our building datasets with the weather data we acquired. We do this in order to be able to use features from the weather data for our forecasting. As we have 2 datasets per each building, one with sun data and the other with energy data, we first have to merge them and then we can add the weather data. We merge the datasets based on the timestamp. This is why we first need to aggregate building data daily. The process for every building is as follows: 3.1.2.1 Building 2 b2_joined &lt;- left_join(building_2, building_2_sun, by = c(&quot;timestamp&quot; = &quot;timestamp&quot;)) summary(b2_joined) ## timestamp energy_produced sun ## Min. :2016-08-09 00:15:00 Min. :0.000 Min. : -0.0867 ## 1st Qu.:2017-04-29 01:45:00 1st Qu.:0.000 1st Qu.: 0.0000 ## Median :2018-01-17 04:00:00 Median :0.000 Median : 0.1733 ## Mean :2018-01-18 21:45:30 Mean :0.457 Mean : 131.1446 ## 3rd Qu.:2018-10-10 22:30:00 3rd Qu.:0.534 3rd Qu.: 177.2333 ## Max. :2019-07-01 00:00:00 Max. :3.760 Max. :1089.6600 # aggregate daily building2 &lt;- b2_joined[, .(daily_total_sun=sum(sun), daily_total_energy=sum(energy_produced)), by=.(Day=floor_date(timestamp, &quot;days&quot;))] summary(building2) ## Day daily_total_sun daily_total_energy ## Min. :2016-08-09 00:00:00 Min. : 0 Min. : 0.00 ## 1st Qu.:2017-04-29 06:00:00 1st Qu.: 4460 1st Qu.: 11.16 ## Median :2018-01-17 12:00:00 Median :10695 Median : 40.00 ## Mean :2018-01-18 22:01:08 Mean :12569 Mean : 43.80 ## 3rd Qu.:2018-10-10 18:00:00 3rd Qu.:20393 3rd Qu.: 76.49 ## Max. :2019-07-01 00:00:00 Max. :32033 Max. :110.75 building2_weather &lt;- left_join(building2, weather, by = c(&quot;Day&quot; = &quot;date_time&quot;)) 3.1.2.2 Building 5 b5_joined &lt;- left_join(building_5, building_5_sun, by = c(&quot;timestamp&quot; = &quot;timestamp&quot;)) b5_joined &lt;- na.omit(b5_joined) # remove the last day --&gt; bc it has NAs summary(b5_joined) ## timestamp energy_produced sun ## Min. :2016-08-09 00:05:00 Min. : 0.000 Min. : -1.056 ## 1st Qu.:2017-04-18 01:56:15 1st Qu.: 0.000 1st Qu.: 1.869 ## Median :2017-12-26 03:47:30 Median : 0.000 Median : 12.919 ## Mean :2017-12-26 03:47:30 Mean : 1.591 Mean : 146.211 ## 3rd Qu.:2018-09-04 05:38:45 3rd Qu.: 2.032 3rd Qu.: 180.131 ## Max. :2019-05-14 07:30:00 Max. :18.560 Max. :1286.025 # aggregate daily building5 &lt;- b5_joined[, .(daily_total_sun=sum(sun), daily_total_energy=sum(energy_produced)), by=.(Day=floor_date(timestamp, &quot;days&quot;))] summary(building5) ## Day daily_total_sun daily_total_energy ## Min. :2016-08-09 Min. : -37.57 Min. : 0.016 ## 1st Qu.:2017-04-18 1st Qu.: 15909.80 1st Qu.: 141.027 ## Median :2017-12-26 Median : 34925.39 Median : 388.544 ## Mean :2017-12-26 Mean : 42080.02 Mean : 457.755 ## 3rd Qu.:2018-09-04 3rd Qu.: 67842.69 3rd Qu.: 758.336 ## Max. :2019-05-14 Max. :110381.37 Max. :1260.672 building5_weather &lt;- left_join(building5, weather, by = c(&quot;Day&quot; = &quot;date_time&quot;)) 3.1.2.3 Building 8 b8_joined &lt;- left_join(building_8, building_8_sun, by = c(&quot;timestamp&quot; = &quot;timestamp&quot;)) summary(b8_joined) ## timestamp energy_produced sun ## Min. :2016-08-09 00:05:00 Min. :0.0000 Min. : 3.354 ## 1st Qu.:2017-04-30 00:03:45 1st Qu.:0.0000 1st Qu.: 3.519 ## Median :2018-01-19 00:02:30 Median :0.0000 Median : 3.675 ## Mean :2018-01-19 00:02:30 Mean :0.3009 Mean : 132.371 ## 3rd Qu.:2018-10-10 00:01:15 3rd Qu.:0.3760 3rd Qu.: 177.771 ## Max. :2019-07-01 00:00:00 Max. :2.3920 Max. :1068.678 # aggregate daily building8 &lt;- b8_joined[, .(daily_total_sun=sum(sun), daily_total_energy=sum(energy_produced)), by=.(Day=floor_date(timestamp, &quot;days&quot;))] summary(building8) ## Day daily_total_sun daily_total_energy ## Min. :2016-08-09 Min. : 3.66 Min. : 0.00 ## 1st Qu.:2017-04-30 1st Qu.: 14104.25 1st Qu.: 29.45 ## Median :2018-01-19 Median : 32361.41 Median : 79.45 ## Mean :2018-01-19 Mean : 38086.76 Mean : 86.58 ## 3rd Qu.:2018-10-10 3rd Qu.: 61039.17 3rd Qu.:142.61 ## Max. :2019-07-01 Max. :151064.61 Max. :214.67 building8_weather &lt;- left_join(building8, weather, by = c(&quot;Day&quot; = &quot;date_time&quot;)) This is how the dataset looks now. It has the amount of sun and energy produced and all other variables from the weather data. 3.2 Feature engineering There are some variables which wouldnt be important for our forecast. As we want to predict energy which highly depends on amount of sun during the day, features like wind temperature, humidity, pressure, visibility, moon illumination and moonrise are not really relevant in this case. Based on our understanding of the domain, important predictors for the energy would be sun, uv index, sun hour and cloud cover because these are the variables which may influence the amount of sun and at the same time the amount of generated energy. Therefore, we decide to keep only these features and discard the others. Building 2: # final building 2 aggregated weekly building2 &lt;- building2_weather[, .(sun=sum(daily_total_sun), energy=sum(daily_total_energy), sunHour=sum(sunHour), uvIndex=sum(uvIndex), cloudcover=sum(cloudcover)), by=.(Week=floor_date(Day, &quot;weeks&quot;))] building2 ## Week sun energy sunHour uvIndex cloudcover ## 1: 2016-08-07 63058.36 235.3050 62.0 22 253 ## 2: 2016-08-14 147175.98 565.9120 99.9 38 188 ## 3: 2016-08-21 137723.81 538.1480 84.9 38 145 ## 4: 2016-08-28 135092.62 538.9766 78.8 41 108 ## 5: 2016-09-04 114039.42 472.4040 74.8 37 203 ## --- ## 148: 2019-06-02 186802.58 638.3960 98.8 39 113 ## 149: 2019-06-09 196700.09 662.3279 99.7 46 76 ## 150: 2019-06-16 176269.59 606.3799 101.5 40 148 ## 151: 2019-06-23 190691.92 634.7160 99.7 42 107 ## 152: 2019-06-30 31125.16 103.2520 29.0 13 15 Building 5: # final building 5 aggregated weekly building5 &lt;- building5_weather[, .(sun=sum(daily_total_sun), energy=sum(daily_total_energy), sunHour=sum(sunHour), uvIndex=sum(uvIndex), cloudcover=sum(cloudcover)), by=.(Week=floor_date(Day, &quot;weeks&quot;))] building5 ## Week sun energy sunHour uvIndex cloudcover ## 1: 2016-08-07 202677.93 2865.728 62.0 22 253 ## 2: 2016-08-14 479672.57 6170.416 99.9 38 188 ## 3: 2016-08-21 447513.56 5510.431 84.9 38 145 ## 4: 2016-08-28 429050.96 5751.301 78.8 41 108 ## 5: 2016-09-04 342232.86 4642.368 74.8 37 203 ## --- ## 141: 2019-04-14 532379.32 6168.128 82.9 28 182 ## 142: 2019-04-21 505690.77 5872.640 92.2 32 239 ## 143: 2019-04-28 372687.61 4444.544 86.6 23 359 ## 144: 2019-05-05 401756.42 4984.448 88.0 23 365 ## 145: 2019-05-12 55829.38 702.592 33.4 8 217 Building 8: # final building 8 aggregated weekly building8 &lt;- building8_weather[, .(sun=sum(daily_total_sun), energy=sum(daily_total_energy), sunHour=sum(sunHour), uvIndex=sum(uvIndex), cloudcover=sum(cloudcover)), by=.(Week=floor_date(Day, &quot;weeks&quot;))] building8 ## Week sun energy sunHour uvIndex cloudcover ## 1: 2016-08-07 195254.33 473.506 62.0 22 253 ## 2: 2016-08-14 442996.59 1052.572 99.9 38 188 ## 3: 2016-08-21 415648.10 986.530 84.9 38 145 ## 4: 2016-08-28 404495.16 954.740 78.8 41 108 ## 5: 2016-09-04 343209.16 831.634 74.8 37 203 ## --- ## 148: 2019-06-02 561870.35 1203.696 98.8 39 113 ## 149: 2019-06-09 591717.49 1262.832 99.7 46 76 ## 150: 2019-06-16 364706.14 1150.704 101.5 40 148 ## 151: 2019-06-23 569457.65 1186.232 99.7 42 107 ## 152: 2019-06-30 93400.23 192.656 29.0 13 15 Creating ts objects so that we can use them for modelling: building_2_ts &lt;- ts(building2, frequency = 52, start = c(2016,8)) building_5_ts &lt;- ts(building5, frequency = 52, start = c(2016,8)) building_8_ts &lt;- ts(building8, frequency = 52, start = c(2016,8)) ggAcf(building_8_ts) We can see that there is a strong seasonality, as lag 0, 52 and 104, so every 52th lag is very high above the line. That means that we have a strong correlation of the previous years. If we think of how the sesons change in each year, this indeed makes a lot of sense. 3.2.1 Time series and decomposing # Weekly data aggregated building_2_sun_weekly &lt;- building_2_sun[, .(weekly_sum=sum(sun)), by=.(Week=floor_date(timestamp, &quot;weeks&quot;))] building_2_weekly &lt;- building_2[, .(weekly_sum=sum(energy_produced)), by=.(Week=floor_date(timestamp, &quot;weeks&quot;))] building_5_sun_weekly &lt;- building_5_sun[, .(weekly_sum=sum(sun)), by=.(Week=floor_date(timestamp, &quot;weeks&quot;))] building_5_weekly &lt;- building_5[, .(weekly_sum=sum(energy_produced)), by=.(Week=floor_date(timestamp, &quot;weeks&quot;))] building_8_sun_weekly &lt;- building_8_sun[, .(weekly_sum=sum(sun)), by=.(Week=floor_date(timestamp, &quot;weeks&quot;))] building_8_weekly &lt;- building_8[, .(weekly_sum=sum(energy_produced)), by=.(Week=floor_date(timestamp, &quot;weeks&quot;))] Here we create time series objects out of monthly and weekly aggregated data and decompose them in order to see their components (trend, data, seasonal component and remainder) building_2_weekly_ts = ts(building_2_weekly[, &quot;weekly_sum&quot;], frequency = 365.25/7, start = c(2016,8)) autoplot(decompose(building_2_weekly_ts, type=&quot;additive&quot;)) building_5_weekly_ts = ts(building_5_weekly[, &quot;weekly_sum&quot;], frequency = 365.25/7, start = c(2016,8)) autoplot(decompose(building_5_weekly_ts, type=&quot;additive&quot;)) building_8_weekly_ts = ts(building_8_weekly[, &quot;weekly_sum&quot;], frequency = 365.25/7, start = c(2016,8)) autoplot(decompose(building_8_weekly_ts, type=&quot;additive&quot;)) The seasonal component shows us how with the time data gets to the same point every month/week, and from the seasonal component the future models will be built upon. The remainders (noise) of these time series seem to be normally distributed (white noice), which indicates that future models will potentially learn from the data and the data is not bad. The trends of the time series are not that smooth in general, which means the predictive power of the models in the future might be quite low, however by combining both seasonal and trend components the predictive power will increase in anyway, since these both are the most important for the future models. 3.2.2 Checking for stationarity Stationarity basically means that the statistical properties of the time series data do not change over time, what is important for many analytical tools and future modeling. adf.test(building_2_weekly_ts) ## ## Augmented Dickey-Fuller Test ## ## data: building_2_weekly_ts ## Dickey-Fuller = -3.4459, Lag order = 5, p-value = 0.04975 ## alternative hypothesis: stationary adf.test(building_5_weekly_ts) ## ## Augmented Dickey-Fuller Test ## ## data: building_5_weekly_ts ## Dickey-Fuller = -2.9694, Lag order = 5, p-value = 0.1728 ## alternative hypothesis: stationary adf.test(building_8_weekly_ts) ## ## Augmented Dickey-Fuller Test ## ## data: building_8_weekly_ts ## Dickey-Fuller = -2.6659, Lag order = 5, p-value = 0.2989 ## alternative hypothesis: stationary The H0 here is that the time series is non-stationary, and the alternative hypothesis is that it is stationary. Since the p-value is only smaller than 0.05 for building 2, we can reject H0 and conclude that this time series is stationary. However, building 5 and 8 are above 0.05, but the nature of the three buildings are similar to each other. As we are going to use data from other sources we will try out modeling with non-stationary data and see how it performs. 3.3 Modeling For the forecasting we are going to try out different models first on one building, which is building 2. The models we are going to compare are: basic arima sarima holt winters arima with external regressors After we have seen how they perform on one building, we will plot the residuals to see which one performs the best on a longer time span. Then the best model is going to be used to forecast the enrgy production of the other building as well. 3.3.0.1 Split into train/test # building 2 training_b2 &lt;- window(building_2_ts, start=c(2016,8),end= c(2018,11)) testing_b2 &lt;- window(building_2_ts, start=c(2018,12) ) # building 5 training_b5 &lt;- window(building_5_ts, start=c(2016,8),end= c(2018,11)) testing_b5 &lt;- window(building_5_ts, start=c(2018,12) ) # building 8 training_b8 &lt;- window(building_8_ts, start=c(2016,8),end= c(2018,11)) testing_b8 &lt;- window(building_8_ts, start=c(2018,12) ) 3.3.1 Arima We first try out the most basic arima model on building 2: arima_basic &lt;- auto.arima(training_b2[,&quot;energy&quot;]) plot(forecast(arima_basic, h=52)) lines(testing_b2[,&quot;energy&quot;], col=&quot;red&quot;) It is not too bad, but also not so good. There is a point at which it is completely unable to capture amount of sun. 3.3.2 Sarima We try out a Sarima model: sarima_forecast &lt;- sarima.for(training_b2[,&quot;energy&quot;], n.ahead = length(testing_b2[,&quot;energy&quot;]), p=0,d=1,q=1, P=1, D=1, Q=0, S=12) 3.3.3 Holt winters # Building 2 autoplot(building_2_ts[,&quot;energy&quot;]) building_2_ts.fc &lt;- HoltWinters(training_b2[,&quot;energy&quot;]) #building_2_weekly_ts.fc$fitted plot(building_2_ts.fc) plot(forecast(building_2_ts.fc, h=52)) lines(testing_b2[,&quot;energy&quot;], col=&quot;red&quot;) 3.3.4 Arima including external regressors We decide to include also other variables to our model. As discussed in Feature Engineering section, we chose sun, sunHour, uvIndex and cloudcover, as we believe they may be relevant for our prediction. arima_b2 &lt;- auto.arima(training_b2[,&quot;energy&quot;], xreg=training_b2[,c(&quot;sun&quot;,&quot;sunHour&quot;, &quot;uvIndex&quot;, &quot;cloudcover&quot;)]) plot(forecast(arima_b2, xreg=testing_b2[,c(&quot;sun&quot;, &quot;sunHour&quot;, &quot;uvIndex&quot;, &quot;cloudcover&quot;)])) lines(testing_b2[,&quot;energy&quot;], col=&quot;red&quot;) "],["results-and-conclusion.html", " 4 Results and conclusion 4.1 Plot residuals of all models for building 2 4.2 Forecast for other buildings 4.3 Summary", " 4 Results and conclusion Plot cumulative sum of the residuals 4.1 Plot residuals of all models for building 2 # from naive forecast plot(cumsum(abs(forecast(arima_basic, h=52)$mean - testing_b2[,&quot;energy&quot;])), type=&quot;l&quot;, col=&quot;red&quot;, ylab=&quot;Cumulative sum of residuals&quot;, xlab=&quot;Predicted days&quot;, main=&quot;Error over time&quot;) # from holt lines(cumsum(abs(forecast(building_2_ts.fc, h=52)$mean - testing_b2[,&quot;energy&quot;])),type=&quot;l&quot;, col=&quot;brown&quot;) # from sarima lines(cumsum(abs(sarima_forecast$pred -testing_b2[,&quot;energy&quot;])),type=&quot;l&quot;, col=&quot;orange&quot;) # from arima with xregs lines(cumsum(abs(forecast(arima_b2, xreg=testing_b2[,c(&quot;sun&quot;, &quot;sunHour&quot;, &quot;uvIndex&quot;, &quot;cloudcover&quot;)])$mean -testing_b2[,&quot;energy&quot;])),type=&quot;l&quot;, col=&quot;blue&quot;) Arima model with external regressors shows the best prediction of energy on building 2. Therefore, we decide to use this model for buildings 5 and 8 as well. Here are the final models for buildings 5 and 8, using Arima with external regressors. 4.2 Forecast for other buildings Arima for building 5: arima_b5 &lt;- auto.arima(training_b5[,&quot;energy&quot;], xreg=training_b5[,c(&quot;sun&quot;,&quot;sunHour&quot;, &quot;uvIndex&quot;, &quot;cloudcover&quot;)]) plot(forecast(arima_b5, xreg=testing_b5[,c(&quot;sun&quot;, &quot;sunHour&quot;, &quot;uvIndex&quot;, &quot;cloudcover&quot;)])) lines(testing_b5[,&quot;energy&quot;], col=&quot;red&quot;) Arima for building 8: arima_b8 &lt;- auto.arima(training_b8[,&quot;energy&quot;], xreg=training_b8[,c(&quot;sun&quot;,&quot;sunHour&quot;, &quot;uvIndex&quot;, &quot;cloudcover&quot;)]) plot(forecast(arima_b8, xreg=testing_b8[,c(&quot;sun&quot;, &quot;sunHour&quot;, &quot;uvIndex&quot;, &quot;cloudcover&quot;)])) lines(testing_b8[,&quot;energy&quot;], col=&quot;red&quot;) The prediction is quite accurate on the other buildings as well. 4.3 Summary Our business objectives have been met, we have explored different models that can be used for forecasting. We have assessed their performance via plotting the difference between the real values and the predicted values (residuals) over time. The model which had the lowest error over time performed the best. Therefore, we can conclude that the arima model performs the best when external regressors are also added. "]]
